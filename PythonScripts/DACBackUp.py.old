import numpy as np
from sympy import *
import matplotlib.pyplot as plt  

#Sc    = sum Ci
#Scb   = sum Ci*Bi
#Sc_B  = sum CBi
#Scb_B = sum CBi*Bi

def dac_out(vr,C_B0l,C_B,C_i,C_Bi, vi, code ):
    #Ver  C_i, C_Bi e code sao arrays
    #Ver tamanho das arrays
    
    numbits = len(code)
    code = np.flip(code)
    print("\nDEBUG "+ str(int(numbits/2)) +"\n")
    #TODO otimizar
    Sc    = sum( C_i )
    Sc_B  = sum( C_Bi )
    #Scb   = sum( C_i[i]*code[i] for i in range(0,int(numbits/2)) )
    #Scb_B = sum( C_Bi[i]*code[i+int(numbits/2)] for i in range(0,int(numbits/2)) )

    Scb   = 0 
    Scb_B = 0 

    for i in range( 0, int(numbits/2)):
        print( "Scb   += "+str(C_i[i])+"*"+str( code[i] ) )
        print( "Scb_B += "+str(C_Bi[i])+"*"+str( code[i+int(numbits/2)] ) )
        Scb   += C_i[i]*code[i+int(numbits/2)]
        Scb_B += C_Bi[i]*code[i]
    
    return vi + vr*( C_B*( Scb_B - Scb ) + Scb*( Sc_B + C_B0l ) )/( C_B*( C_B0l - Sc + Sc_B ) + Sc*( C_B0l + Sc_B ) )

#exemplo para 2 bits de cada lado

C_i   = [1, 2]
C_Bi  = [1, 2]
C_B   = 4
C_B0l = 1
vr    = 1
vi    = 0

res_dac = [ 0 for _ in range(16)]

for n in range (0,16):
    
    tmp = [ int(i) for i in bin(n)[2:] ]
    if len(tmp) < 4:
        code = np.append( [ 0 for _ in range( 4 - len(tmp)  ) ],tmp  )
    
    else:
        code = np.asarray(tmp)

    #print(tmp)
    res_dac[n] = dac_out(vr,C_B0l,C_B,C_i,C_Bi, vi, code )
    print(str(code)+" -> "+str( res_dac[n] ))

plt.plot([ n for n in range(0,16) ], res_dac)
plt.show()
